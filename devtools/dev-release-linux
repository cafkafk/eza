#!/usr/bin/env bash

# This is the preferred release script

set -e

# Linux check!
uname=$(uname -s)
if [[ "$uname" != "Linux" ]]; then
  echo "Gotta be on Linux to run this (detected '$uname')!"
  exit 1
fi

# First, we need to get the version number to figure out what to call the zip.
# What was done here before was a pretty dirty hack. The less we talk about it
# the better...
toml_file="Cargo.toml"
eza_version=$(grep version Cargo.toml | head -n 1 | grep -E '([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?' -o)
if [ -z "$eza_version" ]; then
  echo "Failed to parse version number! Can't build eza!"
  exit 1
fi

# Weekly builds have a bit more information in their version number (see build.rs).
uname=$(uname -s)
if [[ "$1" == "--weekly" ]]; then
  git_hash=$(GIT_DIR=.git git rev-parse --short --verify HEAD)
  date=$(date +"%Y-%m-%d")
  echo "Building eza weekly v$eza_version, date $date, Git hash $git_hash"
else
  echo "Building eza v$eza_version"
fi

# Compilation is done in --release mode, which takes longer but produces a
# faster binary. This binary gets built to a different place, so the extended
# tests script needs to be told which one to use.
echo -e "\n\033[4mCompiling release version of eza...\033[0m"
eza_linux_binary="eza-linux-x86_64"
rm -vf "$eza_linux_binary"
cargo build --release --manifest-path "$toml_file"
cargo test --release --manifest-path "$toml_file" -- --quiet
# /vagrant/xtests/run.sh --release
cp target/release/eza "$eza_linux_binary"

# Stripping the binary before distributing it removes a bunch of debugging
# symbols, saving some space.
echo -e "\n\033[4mStripping binary...\033[0m"
strip -v "$eza_linux_binary"

# Compress the binary for upload. The ‘-j’ flag is necessary to avoid the
# /vagrant path being in the zip too. Only the zip gets the version number, so
# the binaries can have consistent names, and it’s still possible to tell
# different *downloads* apart.
# echo -e "\n\033[4mZipping binary...\033[0m"
# if [[ "$1" == "--weekly" ]]; then
#   eza_linux_zip="eza-linux-x86_64-${eza_version}-${date}-${git_hash}.zip"
# else
#   eza_linux_zip="eza-linux-x86_64.zip"
# fi
# rm -vf "$eza_linux_zip"
# zip -j "$eza_linux_zip" "$eza_linux_binary"
if [[ "$1" == "--weekly" ]]; then
  eza_linux_tar="eza-linux-x86_64-${eza_version}-${date}-${git_hash}.tar.gz"
else
  eza_linux_tar="eza-linux-x86_64.tar.gz"
fi
rm -vf "$eza_linux_tar"
tar czvf "$eza_linux_tar" "$eza_linux_binary"

# There was a problem a while back where a library was getting unknowingly
# *dynamically* linked, which broke the whole ‘self-contained binary’ concept.
# So dump the linker table, in case anything unscrupulous shows up.
echo -e "\n\033[4mLibraries linked:\033[0m"
ldd "$eza_linux_binary" | sed "s/\t//"

# Might as well use it to test itself, right?
echo -e "\n\033[4mAll done! Files produced:\033[0m"
./$eza_linux_binary "$eza_linux_binary" "$eza_linux_tar" -lB
